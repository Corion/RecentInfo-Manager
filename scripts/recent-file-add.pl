#!perl
#use experimental 'class';
use feature 'class';

class RecentInfo::Application 0.01 {
    field $name :param;
    field $exec :param;
    field $count :param;

    method as_XML_fragment($doc) {
        my $app = $doc->createDocumentFragment('bookmark:application');
        $app->setAttribute("name" => $name);
        $app->setAttribute("exec" => $exec);
        $app->setAttribute("count" => $count);
        return $app
    }

    # This should be a constructor but isn't
    method from_XML_fragment( $frag ) {
        $name = $frag->getAttribute('name');
        $exec = $frag->getAttribute('exec');
        $count = $frag->getAttribute('count');

        return $self
    }
}

class RecentInfo::Entry 0.01 {
    field $uri :param ;
    field $display_name :param;
    field $description :param;

    field $added :param;
    field $modified :param;
    field $visited :param;

    field $mime_type :param;
    field @applications :param;

    field @groups :param;

    ADJUST {
        # Convert maybe $added etc. to DateTime or stuff like that?!
    }

    method as_XML_fragment($doc) {
        my $bookmark = $doc->createDocumentFragment('bookmark');
        $bookmark->setAttribute( 'href' => $href );
        #$bookmark->setAttribute( 'app' => $app );
        # XXX Make sure to validate that $modified, $visited etc. are proper DateTime strings
        $bookmark->setAttribute( 'modified' => $modified );
        $bookmark->setAttribute( 'visited' => $visited );
        #$bookmark->setAttribute( 'exec' => "'perl %u'" );
        my $info = $bookmark->addNewChild( undef, 'info' );
        my $metadata = $info->addNewChild( undef, 'metadata' );
        my $mime = $metadata->addNewChild( undef, 'mime-type' );
        $mime->appendText( $mime_type );
        $metadata->setAttribute('owner' => 'http://freedesktop.org' );
        # Should we allow this to be empty, or should we leave it out completely then?!
        my $applications = $metadata->addNewChild( undef, "bookmark:applications" );
        for my $application (@applications) {
            $applications->addNewChild( $application->as_XML_fragment( $doc );
        };
        # What about groups?

        return $bookmark;
    }

    # This should be a constructor but isn't
    method from_XML_fragment( $frag ) {
        $href = $frag->getAttribute('href');
        $modified = $frag->getAttribute('modified');
        $visited = $frag->getAttribute('visited');
        # info/metadata/mime-type
        $mime_type = $frag->find('./info[1]/metadata[1]/mime-type[1]')->getTextContent;
        @applications = map {
            # ...
            # Create fresh objects here
             RecentInfo::Application->new->from_XML_frament($_);
        } $frag->getChildNode('bookmark:applications');
        #...
        return $self
    }

}

package main;

use 5.020;
use experimental 'signatures';

use XML::LibXML;
use XML::LibXML::PrettyPrint;
use IO::AtomicFile;
use File::Spec;
use Date::Format::ISO8601 'gmtime_to_iso8601_datetime';

my $recent = $ENV{XDG_DATA_HOME} . "/recently-used.xbel";

sub validate_xml( $tree ) {
    return 1;

    # One day, we might come up with a valid DTD for the recent documents
    # XBEL. The existing things online don't validate what is generated by Glib.
    state $dtd = do {
        my $dtd_fn = 'dtd/xbel.dtd';
        open my $fh, '<', $dtd_fn
            or die "Couldn't read DTD '$dtd_fn': $!";
        local ($/,@ARGV);
        my $str = <$fh>;
        XML::LibXML::Dtd->parse_string($str);
    };

    $tree->validate( $dtd );
}

sub load_recent_files( $filename ) {
    if( -f $recent ) {
        my $doc = XML::LibXML
                      ->new( load_ext_dtd => 0, keep_blanks => 1, expand_entities => 0, )
                      ->load_xml( location => $filename );
        # Just to make sure we read in valid(ish) data
        #validate_xml( $doc );
        # Parse our tree from the document, instead of using the raw XML
        # as we want to try out the Perl class?!
        # this means we lose comments etc.
        return $doc;
    } else {
        die "No file '$filename'";
    }
}

sub recent_files_to_string( $doc ) {
    my $pp = XML::LibXML::PrettyPrint->new(
        indent_string => '  ',
        element => {
            compact => [qw[ bookmark:group ]],
        },
    );
    $pp->pretty_print( $doc );

    #validate_xml( $doc );

    my $str = $doc->toString(); # so we encode some entities?!

    # Now hardcore encode some entities within attributes/double quotes back
    # because I can't find how to coax XML::LibXML to properly encode entities:
    $str =~ s!exec="'!exec="&apos;!g;
    $str =~ s!'"( |>)!&apos;"$1!g;

    return $str
}

sub save_recent_files( $doc, $filename ) {
    my $str = recent_files_to_string( $doc );

    my $fh = IO::AtomicFile->open( $filename, '>:raw' );
    print $fh $str;
    $fh->close;
}

# XXX change API to use named parameters
# https://www.freedesktop.org/wiki/Specifications/desktop-bookmark-spec/
sub add_recent( $doc, $app, $href, $modified, $visited, $mime_type ) {
    my @bookmarks = $doc->getElementsByTagName('xbel');
    die "Too many bookmark lists ('<xbel>') found in document"
        if @bookmarks > 1;
    my $list = $bookmarks[0];
    $list->appendChild( $bookmark->as_XML_fragment );
}

sub add_recent_file( $doc, $app, $filename, $mime_type ) {
    $filename = File::Spec->rel2abs($filename);
    my $href = "file://$filename";
    my @stat = stat( $filename );
    my $modified = gmtime_to_iso8601_datetime( $stat[9] );
    my $visited = gmtime_to_iso8601_datetime( time );
    add_recent( $doc, $app, $href, $modified, $visited, $mime_type );
}

# Manual test 1 - check behaviour: a manually added file must exist?!
# Manual test 2 - check behaviour: where is a manually added file added in the order?
# Test 1 - create XBEL XML for a single file

my $doc = load_recent_files( $recent );
add_recent_file( $doc, 'perl', $0, 'application/perl' );

my $new = recent_files_to_string( $doc );
use Algorithm::Diff;
my $diff = Algorithm::Diff->new([split /\r?\n/, $org],[split /\r?\n/, $new]);

$diff->Base( 1 );   # Return line numbers, not indices
while(  $diff->Next()  ) {
    next   if  $diff->Same();
    my $sep = '';
    if(  ! $diff->Items(2)  ) {
        printf "%d,%dd%d\n",
            $diff->Get(qw( Min1 Max1 Max2 ));
    } elsif(  ! $diff->Items(1)  ) {
        printf "%da%d,%d\n",
            $diff->Get(qw( Max1 Min2 Max2 ));
    } else {
        $sep = "---\n";
        printf "%d,%dc%d,%d\n",
            $diff->Get(qw( Min1 Max1 Min2 Max2 ));
    }
    print "< $_"   for  $diff->Items(1);
    print $sep;
    print "> $_"   for  $diff->Items(2);
}

#save_recent_files( $doc => "$recent.tmp" );
#save_recent_files( $doc => "$recent" );
